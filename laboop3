#include <iostream>
#include <string>
#include <stdexcept>
#include <iomanip>
using namespace std;

class Product {
private:
    string name;
    int quantity;
    double price;

public:
    Product(string n = "Unknown", int q = 0, double p = 0.0) {
        setName(n);
        setQuantity(q);
        setPrice(p);
    }

    void setName(string n) {
        name = n;
    }

    void setQuantity(int q) {
        if (q < 0) throw invalid_argument("Quantity cannot be negative!");
        quantity = q;
    }

    void setPrice(double p) {
        if (p < 0) throw invalid_argument("Price cannot be negative!");
        price = p;
    }

    string getName() const { return name; }
    int getQuantity() const { return quantity; }
    double getPrice() const { return price; }

    void show() const {
        cout << "Name: " << name
             << ", Quantity: " << quantity
             << ", Price: " << fixed << setprecision(2) << price << endl;
    }

    Product& operator++() {
        ++quantity;
        return *this;
    }

    Product operator++(int) {
        Product temp = *this;
        ++quantity;
        return temp;
    }

    Product& operator--() {
        if (quantity > 0) --quantity;
        return *this;
    }

    Product operator--(int) {
        Product temp = *this;
        if (quantity > 0) --quantity;
        return temp;
    }

    Product& operator=(const Product& other) {
        if (this != &other) {
            name = other.name;
            quantity = other.quantity;
            price = other.price;
        }
        return *this;
    }

    bool operator==(const string& searchName) const {
        return name == searchName;
    }

    bool operator==(double searchPrice) const {
        return price == searchPrice;
    }

    bool operator==(int searchQuantity) const {
        return quantity == searchQuantity;
    }
};

class Warehouse {
private:
    static const int MAX_PRODUCTS = 100;
    Product products[MAX_PRODUCTS];
    int count;

public:
    Warehouse() : count(0) {}

    void addProduct(const Product& p) {
        if (count >= MAX_PRODUCTS) throw overflow_error("Warehouse is full!");
        products[count++] = p;
    }

    Product& getProduct(int index) {
        if (index < 0 || index >= count) throw out_of_range("Invalid index!");
        return products[index];
    }

    void showAll() const {
        cout << "=== Warehouse Content ===" << endl;
        for (int i = 0; i < count; ++i) products[i].show();
    }

    void search(const string& name) const {
        cout << "Search by name \"" << name << "\":" << endl;
        for (int i = 0; i < count; ++i)
            if (products[i] == name) products[i].show();
    }

    void search(double price) const {
        cout << "Search by price " << fixed << setprecision(2) << price << ":" << endl;
        for (int i = 0; i < count; ++i)
            if (products[i] == price) products[i].show();
    }

    void search(int quantity) const {
        cout << "Search by quantity " << quantity << ":" << endl;
        for (int i = 0; i < count; ++i)
            if (products[i] == quantity) products[i].show();
    }

    int size() const { return count; }
};

int main() {
    try {
        Warehouse warehouse;

        warehouse.addProduct(Product("Apples", 50, 12.5));
        warehouse.addProduct(Product("Bananas", 30, 25.0));
        warehouse.addProduct(Product("Oranges", 40, 20.0));

        warehouse.showAll();

        cout << "\n=== Operator Overloading Demo ===" << endl;

        ++warehouse.getProduct(0);
        --warehouse.getProduct(1);
        warehouse.getProduct(2) = warehouse.getProduct(0);

        warehouse.showAll();

        cout << "\n=== Searching Demo ===" << endl;
        warehouse.search("Bananas");
        warehouse.search(12.5);
        warehouse.search(51);

        Product bad("Pears", -10, 15.0);
        warehouse.addProduct(bad);
    }
    catch (const exception& e) {
        cerr << "Error: " << e.what() << endl;
    }

    return 0;
}
