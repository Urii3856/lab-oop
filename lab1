#include <iostream>
#include <cmath>
using namespace std;

// Safe power function (handles negative bases correctly)
double safePowRoot(double base, double expVal) {
    if (base >= 0) {
        return pow(base, expVal);
    }
    else {
        double intPart;
        if (modf(expVal, &intPart) == 0.0) {
            return pow(base, expVal);
        }
        return pow(fabs(base), expVal);
    }
}

// Function a[x, y, z, b]
double calcA(double x, double y, double z, double b) {
    double numerator = sqrt(pow(fabs(x * x - z), 0.3)) - cbrt(fabs(y + 2 * b));
    double denominator = 1.0 + (x / 1.0) + (pow(y, 2) / 2.0) + (pow(z, 3) / 6.0);
    return numerator / denominator;
}

// Function b[x, y, z]
double calcB(double x, double y, double z) {
    double base = x * x + z;
    double part1 = y + atan(safePowRoot(fabs(base), 0.1));
    double part2 = (3.0 / x) + pow(sin(pow(y + z, 3)), 2) + y * exp((-x + z) / (y + z));
    return x * (part1 / part2);
}

int main() {
    int variant = 1; // ‚Üê enter your variant number
    double x = 0.48 * variant;
    double y = 0.47 * variant;
    double z = -1.32 * variant;

    // To test the program, set b as a constant value
    double b = 2.0;

    cout << "Variant " << variant << endl;
    cout << "x = " << x << ", y = " << y << ", z = " << z << ", b = " << b << endl;
    cout << "a[x,y,z,b] = " << calcA(x, y, z, b) << endl;
    cout << "b[x,y,z]   = " << calcB(x, y, z) << endl;

    return 0;
}
